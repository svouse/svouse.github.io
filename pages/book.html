<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400,700;1,400&display=swap');
  </style>
</head>
<body>
<svg version="1.1" id="pg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 217.67 217.67" style="display:none;" xml:space="preserve">
        <path id="logo-p" d="M96.12,34.69c-10.45-6.27-24.27-3.43-33.91,0.29c-9.64,3.72-12.19,5.75-16.55,6.62c-4.36,0.87-5.46,0-5.69-2.03
        	c0.35-0.12,2.32-0.64,1.97-2.32c-0.35-1.68-1.63-2.73-5.57-1.97c-3.95,0.75-6.39,6.16-3.31,9.99c3.08,3.83,6.14,4.36,13.75,3.14
        	c0,0-0.04,42.27-0.04,53.47c0,0,0.24,14.66,0.06,24.79c-0.04,2.51-0.21,4.73-0.46,6.39c-0.59,3.85-1.22,6.16-3.89,7.32
        	c-1.81,0.79-4.47-0.46-3.89-2.56c0.58-2.09-0.29-2.73-1.51-2.84c-1.22-0.12-4.24,1.51-4.3,5.69c0,0-0.48,4.52,5.11,6.36
        	c5.59,1.84,10.48-0.69,13.95-4.9c4.25-5.15,6.64-11.17,7.01-21.16c0.01-0.15,0.01-0.15,0.01-0.13c0-0.11-0.01-0.73-0.01-3.59
        	c0-16.36,0-47.68,0-47.68s-0.14-15.15,0.21-18.41s4.81-11.33,15.93-13.24s21.95,5.81,24.5,21.95s-2.12,33.49-8.99,40.64
        	c-6.87,7.15-11.19,7.5-16.21,6.37c-5.03-1.13-4.53-6.23-3.75-7.79c0.78-1.56,5.1-1.49,3.19-4.25s-8.71-3.61-11.68,0.64
        	c-2.97,4.25-3.82,8.78,1.77,14.51c5.59,5.73,15.93,4.74,24.71,0.7s21.17-16.56,24.71-37.03C116.75,53.22,106.57,40.97,96.12,34.69z"/>
  <path id="logo-g" d="M186.74,86.33c-2.57-2.22-6.3-2.24-8.66-1.14c-2.36,1.11-4.23,2.94-4.55,4.78c-0.32,1.84,0.93,2.54,3.32,2.07
        	s3.21,0.9,2.74,2.65c-0.47,1.75-2.71,2.26-6.06,1.57c-3.36-0.68-8.94-3.75-19.15-4.53s-19-0.1-31.69,10.05
        	c-12.68,10.15-17.6,29.76-15.33,44.49c2.27,14.73,7.96,23.98,18.67,32.88c10.71,8.9,25.37,11.31,37.77,9.35
        	c11.78-1.87,19.96-4.93,21.87-6.91s-0.62-3.5-2.11-5.56c-1.49-2.06-2.76-4.2-2.76-9.45c0-4.46,0-22.62,0-27.23s1.81-5.7,4.04-8.32
        	c0.99-1.16,1.61-2.38,0.54-3.28c-1.34-1.14-3.18-0.17-5.31,0.8c-3.81,1.75-6.73,2.11-13.24,0.85s-9.94-4.25-16.99-4.14
        	c-5.73,0.08-10.33,2.87-12.36,6.74c-2.03,3.87-1.84,9.62,1.52,12.59c3.36,2.97,7.31,1.54,9.26-0.33s1.64-3.99,1.18-6.18
        	c-0.6-2.87-2.44-1.25-4.33-0.12c-0.85,0.51-2.03,0.27-2.38-0.62c-0.43-1.08-0.28-2.48,0.64-3.04c3.16-1.93,7.03,0.35,10.14,1.96
        	c3.12,1.6,5.85,4.25,15.29,1.13c0,0,0,28.53,0,30.61c0,1.09,0.03,3.51,0.75,5.96c0.46,1.55,1.29,3.28,2.11,4.15
        	c0.35,0.37,0.98,1.07-0.16,1.47c-1.14,0.4-14.58,5.49-26.09,0.32c-21.2-9.52-25.68-31.24-26.14-39.28
        	c-0.46-8.04,1.01-19.05,5.05-25.15c4.72-7.13,8.89-12.87,17.46-15.86c8.58-2.99,12.92-1.43,20.82,0.79s11.63,4.14,18.08,3
        	c6.44-1.14,9.01-4.96,9.36-8.98C190.42,90.42,189.31,88.55,186.74,86.33z"/>
    </svg>

</body>
<!--<script async="" src="https://unpkg.com/es-module-shims@0.13.1/dist/es-module-shims.js"></script>-->

<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script type="importmap">
  {
    "imports": {
    "three": "https://unpkg.com/three@0.133.0/build/three.module.js"
  }
  }
</script>

<script type="module">


  import * as THREE from "three";
  import { HDRCubeTextureLoader } from "https://unpkg.com/three@0.133.0/examples/jsm/loaders/HDRCubeTextureLoader.js";
  import { RGBELoader } from 'https://unpkg.com/three@0.133.0/examples/jsm/loaders/RGBELoader.js';
  import { OrbitControls } from "https://unpkg.com/three@0.133.0/examples/jsm/controls/OrbitControls.js";
  import { USDZExporter } from "https://unpkg.com/three@0.133.0/examples/jsm/exporters/USDZExporter.js";
  import { GLTFExporter } from "https://unpkg.com/three@0.133.0/examples/jsm/exporters/GLTFExporter.js";
  import { Geometry } from "https://unpkg.com/three@0.133.0/examples/jsm/deprecated/Geometry.js";

  import { VRButton } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/VRButton.js";
  import { XRControllerModelFactory } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/XRControllerModelFactory.js";
  import { XRHandModelFactory } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/XRHandModelFactory.js";


  window.addEventListener("error", e => {
    alert("Error!\n" + e.name + ":\n" + e.message);
  });

  const smoothstep = (low, high, f) => {
    f = (f - low) / (high - low);
    f = Math.max(0, Math.min(1, f));
    return f * f * (3 - 2 * f);
  };

  class App {
    constructor()
    {
      this.loadedFilename = "Who Stole the Harlem of the West?";   // used as the title in the cover
      this.author = "Digitized by Sage Vousé";
      this.textNumber = "001";  // or any string you’d like
      this.language = "";
      this.releaseDate = "2024";


      this.filename = "Dummy";
      this.camera = new THREE.PerspectiveCamera(45, innerWidth / (innerHeight), .01, 20);
      this.camera.position.set(-0.24, 1.34, 0.51);
      this.initRenderer();


      this.controls = new OrbitControls(this.camera, this.renderer.domElement);
      this.controls.enableDamping = true;
      this.controls.target = new THREE.Vector3(0.02, 1.01, 0.51);

      this.scene = new THREE.Scene();
      // this.scene.add(new THREE.GridHelper(10,10));

      setTimeout(() => {
        this.initHDR();
      }, 500);

      this.initVR();

      this.pagePivot = new THREE.Object3D();
      this.scene.add(this.pagePivot);
      this.pagePivot.scale.setScalar(0.00125);
      this.pagePivot.position.y = 1.058;
      this.pagePivot.position.z = 0.46;


      //this.gui = new dat.GUI();
      this.options = {
        earlyPivot: 2.6,
        latePivot: 17,
        earlyThreshold: 4.5,
        lateThreshold: 12.3,
        earlyIntensity: 8.4,
        lateIntensity: 0.83,
        bookHeight: 18,
        bookWidth: 12,
        curlPivot: 11,
        curlThreshold: 12,
        turnCurveIntensity: 1.4,

      };

      this.pngFiles = [
        'preface.png',
        'dreams_of_death_1.png',
        'magic.png',
        'magic_2.png',
        'creole_1.png',
        'creole_2.png',
      ];
      this.pageTextures = [];

      const loader = new THREE.TextureLoader();
      this.pngFiles.forEach((file, i) => {
        loader.load(
                '/assets/images/book/' + file,
                (texture) => {
                  texture.minFilter = THREE.LinearFilter;
                  this.pageTextures[i] = texture;
                },
                undefined,
                (error) => {
                  console.error('Error loading PNG file:', error);
                }
        );
      });


      //so the lines per page at 180 was 32.
      //at 100 it was 18. 

      /* var curlParams = this.gui.addFolder("curl parameters");
       for (var prop in this.options) {
           curlParams.add(this.options, prop, 0, 20);
       }*/


      Object.assign(this.options, {
        openness: 1,
        linesPerPage: 32,
        turnSpeed: 0.1,
        pageCount: 22,
        autoAdvance: false,
        coverColor: "#fffff",
        typeColor: "black"
      });

      /* this.gui.add(this.options, "openness", 0.00, 1.0).listen();
       this.gui.add(this.options, "turnSpeed", -1, 1).listen();
       this.gui.add(this.options, "autoAdvance");



       this.gui.add(this, "loadText");*/

      this.options.exportModel = () => {
        window.glViewer.exportBook();
      }

      var isPhysical = true;
      //this.gui.add(this.options, "exportModel");
      window.glViewer = this;


      this.buildPages(0.01);

      this.turnAmount = 0;
      this.curPage = 0;
      this.prevPage = -1;
      this.centerCurve = 0;
      this.centerTurnCurve = 0;

      const ticker = new THREE.Mesh(new THREE.PlaneGeometry(0.001, 0.001), new THREE.MeshBasicMaterial({
        color: 'pink'
      }));
      this.scene.add(ticker);
      ticker.position.y = 1;
      ticker.position.z = 0.5;
      ticker.onBeforeRender = () => {

        if (!this.options.autoAdvance) {
          this.options.turnSpeed = this.pageTurnImpulse || 0;
        }

        this.pageTurnImpulse *= 0.95;
        this.turnAmount += (this.options.turnSpeed) / 6 * smoothstep(0.1, 0.2, this.options.openness);
        this.turnAmount = Math.max(0.0, this.turnAmount);
        this.turnAmount = Math.min(this.options.pageCount, this.turnAmount);
        this.curPage = Math.floor(this.turnAmount / 2) * 2;

        this.centerCurve = this.center.curve = 1 - this.turnAmount % 2;
        this.centerTurnCurve = this.center.turnCurve = 2 * smoothstep(1, 0.0, Math.abs(this.center.curve)) * Math.sign(-this.options.turnSpeed);

        if (this.curPage != this.prevPage) {

          requestAnimationFrame(() => {
            if (this.curPage % 1 == 0) {
              this.buildPages(this.curPage / this.options.pageCount + 0.01);
            }
            this.setPagesFrom(this.curPage, Math.sign(this.center.curve), this.left, this.center, this.right);
          });
          this.prevPage = this.curPage;
        }

        this.options.spineCurveIntensity = (this.turnAmount - this.options.pageCount / 2) / this.options.pageCount / 2 * 0.7;
        this.pagePivot.rotation.x = this.pagePivot.rotation.x * 0.9 + 0.1 * ((-this.options.spineCurveIntensity * Math.PI * 1.3) * this.options.openness + (1 - this.options.openness) * Math.PI / 2);
      }
      this.initClickPivots();


    }
    // this.addShelf();



    onPointerMove(event)
    {
      this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    updatePointer()
    {
      this.raycaster.setFromCamera(this.pointer, this.camera);


      if (this.pointerDown) {

        var intersects = this.raycaster.intersectObjects([this.bottomDragPlane], false);
        if (intersects.length > 0) {
          this.hitPoint = intersects[0].point;
          this.clickDot.position.copy(this.hitPoint);

          //let's get that angle! It's in X and Y I think.
          var angle = Math.atan2(this.hitPoint.z - 0.46, this.hitPoint.y - 1.058);
          this.clickDot.position.z = 0.14 * Math.sin(angle) + 0.46;
          this.clickDot.position.y = 0.14 * Math.cos(angle) + 1.058;
          this.dotScreen = this.clickDot.position.clone().project(this.camera);

          this.options.openness = 0.9 * this.options.openness + 0.1 * smoothstep(90, -90, angle * 57);
        }

      } else {


        var intersects = this.raycaster.intersectObjects([this.bottomClickPivot, this.left, this.right], false);
        if (intersects.length > 0) {
          var hit = intersects[0].object
          if (hit == this.bottomClickPivot) {
            this.hoverTarget = this.bottomClickPivot;

          } else if (hit == this.left) {
            this.hoverTarget = this.left;
            this.left.rightPage.emissive = new THREE.Color(1, 1, 0.5);
            this.right.leftPage.emissive = new THREE.Color(0, 0, 0);
          } else if (hit == this.right) {
            this.right.leftPage.emissive = new THREE.Color(1, 1, 0.5);
            this.left.rightPage.emissive = new THREE.Color(0, 0, 0);
            this.hoverTarget = this.right;
          }
        } else {
          this.left.rightPage.emissive = new THREE.Color(0, 0, 0);
          this.right.leftPage.emissive = new THREE.Color(0, 0, 0);
          this.hoverTarget = null;
        }
      }
    }

    onPointerDown(event)
    {
      if (this.hoverTarget != null) {
        if (this.hoverTarget == this.left) {
          this.pageTurnImpulse -= 0.5;
          return;
        }
        if (this.hoverTarget == this.right) {
          this.pageTurnImpulse += 0.5;
          return;
        }

        this.pointerDown = true;
        this.controls.saveState();
        this.controls.enabled = false;
      } else {
        if (!this.controls.enabled) {
          this.controls.enabled = true;
          this.controls.reset();
        }
      }
    }

    initClickPivots()
    {
      this.raycaster = new THREE.Raycaster();
      this.pointer = new THREE.Vector2();
      this.clickDot = new THREE.Mesh(new THREE.SphereGeometry(0.000003, 12, 12), new THREE.MeshBasicMaterial({
        color: 'red'
      }));
      this.scene.add(this.clickDot);
      this.pageTurnImpulse = 0;
      this.dotScreen = new THREE.Vector3();
      document.addEventListener('pointermove', e => this.onPointerMove(e));
      document.addEventListener('pointerdown', e => this.onPointerDown(e));
      document.addEventListener('pointerup', e => {
        this.pointerDown = false;
      });
      this.hoverTarget = null;
      this.pointerDown = false;



    }

    processFile(loadEvent)
    {
      this.text = loadEvent.target.result.split("\n");
      this.options.linesPerPage = (this.options.bookHeight - 1) * 1.92;
      this.options.pageCount = Math.ceil(this.text.length / this.options.linesPerPage / 2) * 2;
      //let's get the title!

      this.title = null;
      this.author = null;
      this.textNumber = null;


      for (var n = 0; n < 50; n++) {
        var splitter = this.text[n].split("itle: ");
        if (splitter.length > 1) {
          this.title = splitter[1];
        }

        splitter = this.text[n].split("anguage: ");
        if (splitter.length > 1) {
          this.language = splitter[1];
        }

        splitter = this.text[n].split("uthor: ");
        if (splitter.length > 1) {
          this.author = splitter[1];
        }

        splitter = this.text[n].toLowerCase().split("elease date: ");
        if (splitter.length > 1) {
          this.releaseDate = splitter[1].split("[")[0];
        }

        splitter = this.text[n].replace(/[\[\]]/g, "").toLowerCase().split(/ebook #|etext #/);
        if (splitter.length > 1) {
          this.textNumber = splitter[splitter.length - 1];
        }

      }
      this.loadedFilename = this.title;
    }




    loadText()
    {
      const input = document.createElement('input');
      input.type = "file";
      var filename;
      input.addEventListener('change', changeEvent => {
        var fR = new FileReader();
        fR.addEventListener('load', loadEvent => this.processFile(loadEvent));
        // debugger;
        filename = changeEvent.target.files[0].name;
        fR.readAsText(changeEvent.target.files[0]);
      });

      input.click();



    }

    drawBorder(g, aspect)
    {
      var borderString = new Path2D("M121.05,116.02c0,0,0-23.72,0-41.47s0-44.96,0-44.96H34.62M93.05,86.02c0,0,93.59,0,103.98,0s91.8,0,91.8,0V30.15h259.52M0,0.5h97.36v64.66c0,0,29.26,0,41.39,0c12.12,0,35.89,0,35.89,0V0.5h566.22");
      var margin = 40;
      var scale = 0.55;

      g.save();
      g.scale(scale, scale);
      g.save();
      g.translate(margin, margin);
      g.stroke(borderString);
      g.restore();

      g.save();
      g.translate(margin, margin);
      g.rotate(Math.PI / 2);
      g.scale(1, -1);
      g.stroke(borderString);
      g.restore();


      g.save();
      g.translate(1024 / scale - margin, margin);
      g.scale(-1, 1);
      g.stroke(borderString);
      g.restore();

      g.save();
      g.translate(1024 / scale - margin, margin);
      g.rotate(-Math.PI / 2);
      g.scale(-1, -1);
      g.stroke(borderString);
      g.restore();

      g.translate(0, 1024 / scale / aspect);
      g.scale(1, -1);
      g.save();
      g.translate(margin, margin);
      g.stroke(borderString);
      g.restore();

      g.save();
      g.translate(margin, margin);
      g.rotate(Math.PI / 2);
      g.scale(1, -1);
      g.stroke(borderString);
      g.restore();


      g.save();
      g.translate(1024 / scale - margin, margin);
      g.scale(-1, 1);
      g.stroke(borderString);
      g.restore();

      g.save();
      g.translate(1024 / scale - margin, margin);
      g.rotate(-Math.PI / 2);
      g.scale(-1, -1);
      g.stroke(borderString);
      g.restore();



      g.restore();
    }

    stampLogo(g, aspect)
    {
      var logoP = new Path2D(document.querySelector("#logo-p").getAttribute('d'));
      var logoG = new Path2D(document.querySelector("#logo-g").getAttribute('d'));
      g.save();

      g.font = "30px Libre Baskerville";
      g.fillText("A", 340, 55);
      g.fillText("Imprint", 599, 55);
      g.font = "italic 30px Libre Baskerville";
      g.fillText("Project Gutenberg", 370, 55);
      g.font = "40px Libre Baskerville";
      var w = g.measureText("#" + this.textNumber).width;
      g.fillText("#" + this.textNumber, 512 - w / 2, 275);
      g.font = "30px Libre Baskerville";
      var w = g.measureText(this.language).width;
      g.fillText(this.language, 512 - w / 2, 1024 / aspect - 15);
      g.translate(512 - 220 / 2, 55);
      g.fill(logoP);
      g.fill(logoG);
      g.restore();




    }
    coverPage()
    {

      if (window.cover == null || this.filename != this.loadedFilename) {
        this.filename = this.loadedFilename;
        const c = document.createElement('canvas');
        c.width = c.height = 1024;
        var aspect = this.options.bookWidth / this.options.bookHeight;
        const g = c.getContext('2d');

        var gold = this.options.typeColor;
        g.fillStyle = this.options.coverColor;
        g.fillRect(0, 0, 1024, 1024);

        const ormC = document.createElement('canvas');
        ormC.width = ormC.height = 1024;
        const ormG = ormC.getContext('2d');
        ormG.fillStyle = "rgb(0,80,0)";

        ormG.fillRect(0, 0, 1024, 1024);

        for (var i = 0; i < 20; i++) {
          var rx = Math.random() * 1024;
          var ry = Math.random() * 1024;
          const radialGrad = ormG.createRadialGradient(rx, ry, 0, rx, ry, 400 + Math.random() * 100);
          const rough = Math.floor(32 + Math.random() * (255 - 32));
          radialGrad.addColorStop(0, `rgba(0,${rough},0,0.25)`);
          radialGrad.addColorStop(1, `rgba(0,${rough},0,0)`);
          ormG.fillStyle = radialGrad;
          ormG.fillRect(0, 0, 1024, 1024);

        }


        const bumpC = document.createElement('canvas');
        bumpC.width = bumpC.height = 1024;
        const bumpG = bumpC.getContext('2d');
        bumpG.fillStyle = "gray";
        bumpG.fillRect(0, 0, 1024, 1024);

        g.scale(1, aspect);
        ormG.scale(1, aspect);
        bumpG.scale(1, aspect);


        g.fillStyle = gold;
        g.font = "700 80px Libre Baskerville";





        g.strokeStyle = gold;
        g.lineWidth = "8";
        g.lineJoin = "round";
        g.lineCap = "square";

        this.drawBorder(g, aspect);

        ormG.lineWidth = "8";
        ormG.lineJoin = "round";
        ormG.lineCap = "square";
        ormG.strokeStyle = "rgb(0, 30,255)";

        bumpG.lineWidth = "8";
        bumpG.lineJoin = "round";
        bumpG.lineCap = "square";
        bumpG.strokeStyle = "rgb(255, 30,255)";

        this.drawBorder(ormG, aspect);
        this.drawBorder(bumpG, aspect);

        //bottom BR eighth:
        // g.save();
        // g.scale(0.5, 0.5);
        // g.translate(1024*2-30,2*1024/aspect-30);
        // g.rotate(-Math.PI/2);
        // g.scale(-1,-1);
        // g.stroke(borderString);
        // g.restore();


        //this.stampLogo(g, aspect);
        ormG.fillStyle = "rgb(0, 50,255)";
        //this.stampLogo(ormG, aspect);

        bumpG.fillStyle = "white";
        //this.stampLogo(bumpG, aspect);

        var title = this.filename || "Your book title is loading ";
        var titleLines = title.split(" ").reduce((o, e) => {
          var widthWithNext = g.measureText(o[o.length - 1] + " " + e).width;
          if (widthWithNext > 900) {
            o.push(e);
          } else
            o[o.length - 1] = o[o.length - 1] + " " + e
          return o;
        }, [[""]]);
        // debugger;
        var w = g.measureText(title).width;





        ormG.fillStyle = "rgb(0, 50,255)";
        ormG.font = "700 80px Libre Baskerville";



        bumpG.shadowColor = "rgba(255,255,255,1)";
        bumpG.shadowBlur = 3;
        var shadowOffset = 2000;
        bumpG.shadowOffsetX = 0;
        bumpG.shadowOffsetY = shadowOffset * aspect;
        bumpG.fillStyle = "black";
        bumpG.font = "700 80px Libre Baskerville";

        titleLines.forEach((line, i, a) => {

          var w = g.measureText(line).width;
          ormG.fillText(line, 512 - w / 2, 512 / aspect + (i - a.length / 2) * 100);
          g.fillText(line, 512 - w / 2, 512 / aspect + (i - a.length / 2) * 100);
          bumpG.fillText(line, 512 - w / 2, 512 / aspect + (i - a.length / 2) * 100 - shadowOffset);
        });
        ormG.font = g.font = bumpG.font = "40px Libre Baskerville";
        var w = g.measureText(this.author || "Anonymous").width;
        ormG.fillText(this.author, 512 - w / 2, 512 / aspect + (titleLines.length / 2) * 100 - 40);
        g.fillText(this.author, 512 - w / 2, 512 / aspect + (titleLines.length / 2) * 100 - 40);

        bumpG.fillText(this.author, 512 - w / 2, 512 / aspect + (titleLines.length / 2) * 100 - 40 - shadowOffset);

        g.strokeStyle = gold;
        g.lineWidth = 5;
        ormG.strokeStyle = "rgb(0, 50,255)";
        ormG.lineWidth = 5;
        bumpG.strokeStyle = "rgba(255,255,255,1)";
        bumpG.lineWidth = 5;
        for (var i = 1; i < 4; i++) {




        }

        const tex = canvas => {
          const t = new THREE.CanvasTexture(canvas);
          t.wrapS = t.wrapT = THREE.RepeatWrapping;
          t.rotation = Math.PI / 2;
          return t;
        }
        window.cover = {
          map: tex(c),
          metalnessMap: tex(ormC),
          normalMap: tex(this.bumpToNormal(bumpC, 1, 0.5))
        };
      }



      return window.cover;
    }

    buildPages(currentOffset)
    {
      while (this.pagePivot.children.length > 0)
        this.pagePivot.remove(this.pagePivot.children[0]);


      const bottomClickPivot = this.bottomClickPivot = new THREE.Mesh(new THREE.TorusGeometry(115, 5, 16, 100), new THREE.ShaderMaterial({
        fragmentShader: `

        uniform float hovered;
        uniform vec2 resolution;
        uniform vec2 pointerLocation;

        void main() {
          vec2 aspect = vec2(1., resolution.x/resolution.y);
          float dist = length(((pointerLocation/2. + 0.5 )- gl_FragCoord.xy/resolution.xy)/aspect);
          vec4 hoveredColor = vec4(1.0, hovered, 0.0, 1.0);
          vec4 transparent = vec4(0.,0.,0.,0.);
          gl_FragColor = mix(hoveredColor, transparent, smoothstep(0.0, 0.05, dist));
        }


        `
















        ,
        transparent: true,
        blending: THREE.AdditiveBlending,
        uniforms: {
          hovered: {
            value: 0
          },
          pointerLocation: {
            value: new THREE.Vector2()
          },
          resolution: {
            value: new THREE.Vector2()
          }

        }

      }));
      const bottomDragPlane = this.bottomDragPlane = new THREE.Mesh(new THREE.CircleGeometry(145, 32), new THREE.MeshBasicMaterial({
        color: 'pink',
        side: THREE.DoubleSide
      }));
      bottomDragPlane.visible = false;
      // bottomClickPivot.visible = false;
      bottomDragPlane.rotation.x = Math.PI / 2;
      bottomDragPlane.rotation.y -= Math.PI / 2;
      bottomDragPlane.position.x = -90;

      this.pagePivot.add(bottomClickPivot);
      this.pagePivot.add(bottomDragPlane);
      bottomClickPivot.rotation.y = Math.PI / 2;
      bottomClickPivot.rotation.z = Math.PI / 2;
      bottomClickPivot.position.x = -90;
      bottomClickPivot.onBeforeRender = () => {

        if (this.pointerDown) {

          bottomClickPivot.material.uniforms.pointerLocation.value.copy(this.dotScreen);
        } else {
          bottomClickPivot.material.uniforms.pointerLocation.value.copy(this.pointer);

        }
        bottomClickPivot.material.uniforms.hovered.value = this.pointerDown ? 1 : 0;
        bottomClickPivot.material.uniforms.resolution.value.set(innerWidth, innerHeight).multiplyScalar(devicePixelRatio);

      };
      var currentOffset = Math.max(0.001, this.curPage / this.options.pageCount);
      var remainder = 1 - currentOffset;

      var totalWidth = this.options.pageCount / 10;
      var remainder = 1 - currentOffset;


      this.left = this.addPage(totalWidth * currentOffset, -totalWidth * currentOffset * 0.5);
      this.right = this.addPage(totalWidth * remainder, totalWidth * remainder * 0.5);
      this.center = this.addPage(0.01, 0);
      this.center.receiveShadow = false;
      const pageParts = this.coverPage();
      this.left.leftPage.map = pageParts.map;
      this.left.leftPage.metalness = this.left.leftPage.roughness = 1;
      this.left.leftPage.metalnessMap = this.left.leftPage.roughnessMap = pageParts.metalnessMap;
      this.left.leftPage.normalMap = pageParts.normalMap;

      this.left.curve = -1;
      this.right.curve = 1;
      this.center.curve = this.centerCurve;
      this.center.turnCurve = this.centerTurnCurve;
      this.left.onBeforeRender();
      this.right.onBeforeRender();
      this.center.onBeforeRender();

      this.pagePivot.add(this.left);
      this.pagePivot.add(this.right);
      this.pagePivot.add(this.center);



      this.right.position.y = this.center.position.y = this.left.position.y = 57;
      this.right.position.z = this.center.position.z = this.left.position.z = (currentOffset - 0.5) * totalWidth;
    }

    setPagesFrom(startPos, direction, left, center, right)
    {


      left.rightPage.map = this.pageTexture(startPos, 0);
      center.leftPage.map = this.pageTexture(startPos + 1, 1);
      center.rightPage.map = this.pageTexture(startPos + 2, 0);
      right.leftPage.map = this.pageTexture(startPos + 3, 1);


    }


    addShelf()
    {
      var o = {
        thickness: 0.026,
        height: 1.6,
        width: 0.92,
        depth: 0.33,
        shelfSpans: 5,
        cornerRadius: 0.0015
      };

      const normalMap = this.getWoodTexture();
      const shelfMaterial = new THREE.MeshStandardMaterial({
        color: 0x100802,
        roughness: 1,
        roughnessMap: this.noiseMap(),
        normalMap
      });
      var side = new THREE.Mesh(new RoundBox(o.thickness, o.depth, o.height + o.thickness, o.cornerRadius), shelfMaterial);
      side.rotation.x = Math.PI / 2;
      var shelfPivot = new THREE.Object3D();
      shelfPivot.add(side);
      side.position.x = o.width / 2 + o.thickness / 2;
      side = side.clone();
      side.position.x *= -1;
      shelfPivot.add(side);
      var basePlank = new THREE.Mesh(new RoundBox(o.width, o.thickness, o.depth, o.cornerRadius), shelfMaterial);
      for (var i = 0; i <= o.shelfSpans; i++) {
        var plank = basePlank.clone();
        shelfPivot.add(plank);
        plank.material = plank.material.clone();
        plank.material.roughnessMap = this.noiseMap();
        plank.material.normalMap = this.getWoodTexture();
        plank.position.y = (i / o.shelfSpans - 0.5) * o.height;
      }
      shelfPivot.position.y = o.height / 2;
      this.scene.add(shelfPivot);
    }


    noiseMap()
    {
      const c = document.createElement('canvas');
      c.width = c.height = 1024;
      const g = c.getContext('2d');
      g.fillStyle = "gray";
      g.fillRect(0, 0, 1024, 1024);
      g.globalAlpha = 0.3;
      for (var i = 0; i < 1e4; i++) {
        g.fillStyle = `hsl(0, 100%, ${Math.floor(Math.random() * 10 + 70)}%)`;
        g.fillRect(Math.random() * 1024, Math.random() * 1024, 50,20);

      }

      return new THREE.CanvasTexture(c);
    }


    bumpToNormal(canvas, offset=1, intensity=1)
    {
      const g = canvas.getContext('2d');
      const src = g.getImageData(0, 0, canvas.width, canvas.height);
      const dest = g.getImageData(0, 0, canvas.width, canvas.height);


      for (var i = 0; i < src.data.length; i += 4) {

        //TODO this doesn't resolve over the width boundary!
        var red = (src.data[i + 0] - src.data[i + 4 * offset]) * intensity;
        var green = (src.data[i + 0] - src.data[i + 4 * offset * canvas.width]) * intensity;
        var blue = 255 - Math.abs(red) - Math.abs(green);

        dest.data[i + 0] = 128 + red;
        dest.data[i + 1] = 128 + green;
        dest.data[i + 2] = blue;
        dest.data[i + 3] = 255;
      }

      g.putImageData(dest, 0, 0);
      return canvas;
    }



    getWoodMap(hue=0)
    {
      const c = document.createElement('canvas');
      c.width = c.height = 1024;
      const g = c.getContext('2d');
      c.style.outline = "2px solid blue";
      const grad = g.createLinearGradient(0, 0, 0, 1024);
      for (var i = 0; i < 50; i++) {

        grad.addColorStop(Math.random(), `hsl(${hue}, 100%, ${Math.floor(Math.random() * 100)}%)`);
      }
      g.fillStyle = grad;
      g.fillRect(0, 0, 1024, 1024);
      return c;
    }



    getWoodTexture()
    {
      var c1 = this.getWoodMap(0);

      var c2 = this.getWoodMap(0);
      var c3 = document.createElement('canvas');
      c3.width = c3.height = 1024;


      const g3 = c3.getContext('2d');
      const grad = g3.createLinearGradient(0, 0, 1024, 0);
      grad.addColorStop(0, "transparent");
      grad.addColorStop(0.5, "white");
      grad.addColorStop(1, "transparent");
      g3.fillStyle = grad;
      g3.fillRect(0, 0, 1024, 1024);
      g3.globalCompositeOperation = "xor";
      g3.drawImage(c2, 0, 0);
      const g1 = c1.getContext('2d');
      g1.drawImage(c3, 0, 0);
      return new THREE.CanvasTexture(this.bumpToNormal(c1, 1, 1));
    }

    addPage(thickness, xOffset=0)
    {

      thickness = Math.max(0.01, thickness);
      const segmentHeight = 6;
      const segmentCount = 20;
      const height = segmentHeight * segmentCount;
      const halfHeight = height * 0.5;

      const sizing = {
        segmentHeight: segmentHeight,
        segmentCount: segmentCount,
        height: height,
        thickness,
        xOffset,
        halfHeight: halfHeight
      };
      const geometry = this.createGeometry(sizing);
      const bones = this.createBones(sizing);
      const mesh = this.createMesh(geometry, bones);


      mesh.curve = 0;
      mesh.turnCurve = 0;
      mesh.onBeforeRender = () => {
        var sT = Math.sin(Date.now() / 10000);
        var amt = 0.8 * sT;
        bones.forEach((b, i) => {

          var distToEarlyCurve = Math.abs(i - this.options.earlyPivot);
          var earlyCurveContribution = smoothstep(this.options.earlyThreshold, 0, distToEarlyCurve);

          var distToLateCurve = Math.abs(i - this.options.latePivot);
          var lateCurveContribution = smoothstep(this.options.lateThreshold, 0, distToLateCurve);


          var distToLateCurve = Math.abs(i - this.options.curlPivot);
          var curlCurveContribution = smoothstep(this.options.curlThreshold, 0, distToLateCurve);

          var spineCurveContribution = smoothstep(7, 1, i);

          b.rotation.x = this.options.earlyIntensity / 20 * earlyCurveContribution * mesh.curve * this.options.openness
                  - this.options.lateIntensity / 20 * lateCurveContribution * mesh.curve * this.options.openness
                  + this.options.turnCurveIntensity / 20 * curlCurveContribution * mesh.turnCurve * this.options.openness;
          b.rotation.y = -Math.sign(this.options.turnSpeed) * (0.15 * b.rotation.x * mesh.turnCurve * curlCurveContribution);
          b.rotation.x += this.options.spineCurveIntensity * spineCurveContribution * this.options.openness;
        });
      };
      mesh.leftPage = mesh.material[5];
      mesh.rightPage = mesh.material[4];
      return mesh;
    }

    pageTexture(pageNumber, side) {
      const index = pageNumber;
      if (this.pageTextures && this.pageTextures[index]) {
        const tex = this.pageTextures[index];
        tex.center = new THREE.Vector2(0.5, 0.5);
        tex.rotation = Math.PI / 2;
        return tex;
      } else {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, 1024, 1024);
        return new THREE.CanvasTexture(canvas);
      }
    }



    bookGrid(angle=0)
    {

      if (this.pagesGrid == null) {
        const c = document.createElement('canvas');
        c.width = c.height = 1024;
        const g = c.getContext('2d');
        g.fillStyle = "gray";
        g.fillRect(0, 0, 1024, 1024);
        g.globalAlpha = 1;
        for (var i = 0; i < 1e2; i++) {
          g.fillStyle = `hsl(0, 10%, ${Math.floor(Math.random() * 10 + 70)}%)`;
          g.fillRect(0, Math.random() * 1024, 1024, 15);

        }
        this.pagesGrid = c;
      }
      const t = new THREE.CanvasTexture(this.pagesGrid);

      t.rotation = angle;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      return t
    }

    blankTexture()
    {
      const c = document.createElement('canvas');
      const g = c.getContext('2d');
      c.width = c.height = 4;
      g.fillStyle = this.options.coverColor;
      g.fillRect(0, 0, 4, 4);
      return new THREE.CanvasTexture(c);
    }

    createMesh(geometry, bones)
    {

      var bgX = new THREE.MeshStandardMaterial({
        map: this.bookGrid()
      });
      var bgNY = new THREE.MeshStandardMaterial({
        map: this.bookGrid(-Math.PI / 2)
      });
      var red = new THREE.MeshStandardMaterial({
        color: this.options.coverColor
      });
      var bgY = new THREE.MeshStandardMaterial({
        map: this.bookGrid(Math.PI / 2)
      });
      const materials = [bgNY, bgY, bgX, red];
      for (var i = 0; i < 2; i++) {
        const material = new THREE.MeshStandardMaterial({
          map: this.blankTexture(),
          roughness: 0.5,
          metalness: 0
        });
        materials.push(material);

      }


      const mesh = new THREE.SkinnedMesh(geometry, materials);
      const skeleton = new THREE.Skeleton(bones);

      mesh.add(bones[0]);

      mesh.bind(skeleton);

      mesh.castShadow = true;
      mesh.receiveShadow = true;
      // // const skeletonHelper = new THREE.SkeletonHelper( mesh );
      // skeletonHelper.material.linewidth = 2;

      return mesh;
    }
    createBones(sizing)
    {

      const bones = [];

      let prevBone = new THREE.Bone();
      bones.push(prevBone);
      prevBone.position.y = -sizing.halfHeight;

      for (let i = 0; i < sizing.segmentCount; i++) {

        const bone = new THREE.Bone();
        bone.position.y = sizing.segmentHeight;
        bones.push(bone);
        prevBone.add(bone);
        prevBone = bone;

      }

      return bones;

    }
    createGeometry(sizing)
    {

      const geometry = new THREE.BoxGeometry(10 * this.options.bookHeight, sizing.height, sizing.thickness, 2, sizing.segmentCount * 5);
      // const geometry = new THREE.PlaneGeometry(180,sizing.height,2,sizing.segmentCount*5);

      for (var n = 0; n < geometry.attributes.position.array.length; n += 3) {
        geometry.attributes.position.array[n + 2] += sizing.xOffset;
      }
      const position = geometry.attributes.position;

      const vertex = new THREE.Vector3();

      const skinIndices = [];
      const skinWeights = [];

      for (let i = 0; i < position.count; i++) {

        vertex.fromBufferAttribute(position, i);

        const y = (vertex.y + sizing.halfHeight);

        const skinIndex = Math.floor(y / sizing.segmentHeight);
        const skinWeight = (y % sizing.segmentHeight) / sizing.segmentHeight;

        skinIndices.push(skinIndex, skinIndex + 1, 0, 0);
        skinWeights.push(1 - skinWeight, skinWeight, 0, 0);

      }

      geometry.setAttribute('skinIndex', new THREE.Uint16BufferAttribute(skinIndices, 4));
      geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeights, 4));

      return geometry;

    }

    exportBook()
    {
      const exporter = new GLTFExporter();
      exporter.parse(this.scene, data => {
        const blob = new Blob([data], {
          type: 'application/octet-stream'
        });
        const a = Object.assign(document.createElement('a'), {
          download: 'model.glb',
          href: URL.createObjectURL(blob)
        });
        a.click();
      }, {
        binary: true
      });

    }
    initRenderer()
    {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(innerWidth, innerHeight);
      this.renderer.setClearColor(0x202020);
      this.renderer.setAnimationLoop(e => this.update(e));
      this.renderer.setPixelRatio(devicePixelRatio);
      this.renderer.xr.enabled = true;
      Object.assign(this.renderer.domElement.style, {
        position: 'fixed',
        top: 0,
        left: 0,

      });

      this.renderer.domElement.addEventListener('dragover', e => {
        e.preventDefault();
      });
      this.renderer.domElement.addEventListener('dragenter', e => {
        e.preventDefault();

      });
      this.renderer.domElement.addEventListener('dragleave', e => {
        e.preventDefault();

      });
      this.renderer.domElement.addEventListener('drop', e => {
        e.preventDefault();
        if (e.dataTransfer.files.length) {
          const fR = new FileReader();
          fR.addEventListener('load', loadEvt => this.processFile(loadEvt));
          fR.readAsText(e.dataTransfer.files[0]);
        }
      });

      document.body.appendChild(this.renderer.domElement);
    }


    initVR()
    {
      const controllerModelFactory = new XRControllerModelFactory();
      const handModelFactory = new XRHandModelFactory().setPath("https://threejs.org/examples/models/fbx/");

      const addControls = number => {
        const controller = this.renderer.xr.getController(number);
        this.scene.add(controller);
        const grip = this.renderer.xr.getControllerGrip(number);
        grip.add(controllerModelFactory.createControllerModel(grip));
        this.scene.add(grip);
        const hand = this.renderer.xr.getHand(number);

        hand.add(handModelFactory.createHandModel(hand));

        this.scene.add(hand);
        return {
          controller,
          grip,
          hand
        };
      };
      this.zero = addControls(0);
      this.one = addControls(1);
      //this.vrButton = VRButton.createButton(this.renderer);
      //document.body.appendChild(this.vrButton);
    }

    update(e)
    {
      this.controls.update();
      this.updatePointer();
      this.renderer.render(this.scene, this.camera);
    }

    initHDR()
    {
      this.renderer.physicallyCorrectLights = true;
      this.renderer.toneMapping = THREE.LinearToneMapping;
      this.renderer.outputEncoding = THREE.sRGBEncoding;
      this.renderer.toneMappingExposure = 0.3;
      this.renderer.shadowMap.enabled = true;


      const light = new THREE.DirectionalLight(0xdfebff, 1.25);
      light.position.set(0, 2, 1);

      light.castShadow = true;
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
      light.shadow.camera.left = -0.13;
      light.shadow.camera.right = 0.13;
      light.shadow.camera.top = 0.2;
      light.shadow.camera.bottom = -0.2;

      light.shadow.camera.near = .8;
      light.shadow.camera.far = 1.2;
      this.scene.add(light);
      // this.scene.add( new THREE.CameraHelper( light.shadow.camera ) );

      new RGBELoader()
              .setDataType(THREE.HalfFloatType)
              .setPath('https://threejs.org/examples/textures/equirectangular/')
              .load('royal_esplanade_1k.hdr', texture => {
                const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                pmremGenerator.compileEquirectangularShader();
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                this.scene.environment = envMap;
                texture.dispose();
                pmremGenerator.dispose();
              });
    }
  }

  class RoundBox extends THREE.BufferGeometry {

    constructor(width=1, height=1, depth=1, radius=1, spans=5)
    {

      super();
      this.root = new THREE.Object3D();

      this.width = width;
      this.height = height;
      this.depth = depth;
      this.radius = radius;
      this.spans = spans;
      var xyz = [(this.width / 2 - this.radius), (this.height / 2 - this.radius), (this.depth / 2 - this.radius)];

      var plane = this._plane(0, 1, xyz);
      plane.position.set(0, 0, this.depth / 2);

      plane = this._plane(0, 1, xyz);
      plane.position.set(0, 0, -this.depth / 2);
      plane.rotation.x = Math.PI;

      plane = this._plane(2, 1, xyz);
      plane.position.set(this.width / 2, 0, 0);
      plane.rotation.y = Math.PI / 2;

      plane = this._plane(2, 1, xyz);
      plane.position.set(-this.width / 2, 0, 0);
      plane.rotation.y = -Math.PI / 2;

      plane = this._plane(0, 2, xyz);
      plane.position.set(0, (this.height / 2), 0);
      plane.rotation.x = -Math.PI / 2;

      plane = this._plane(0, 2, xyz);
      plane.position.set(0, (-this.height / 2), 0);
      plane.rotation.x = Math.PI / 2;

      var coefsA = [[1, 0, 1], [1, 0, -1], [-1, 0, -1], [-1, 0, 1]];
      var coefsB = [[0, 1, 1], [0, 1, -1], [0, -1, -1], [0, -1, 1]];
      var coefsC = [[1, -1, 0], [1, 1, 0], [-1, 1, 0], [-1, -1, 0]];

      for (var i = 0; i < coefsA.length; i++) {
        var cyl = this._cyl(this.height, i);
        this._setPos(cyl, coefsA[i], xyz);

        cyl = this._cyl(this.width, i);
        this._setPos(cyl, coefsB[i], xyz);
        cyl.rotation.z = Math.PI / 2;

        cyl = this._cyl(this.depth, i);
        this._setPos(cyl, coefsC[i], xyz);
        cyl.rotation.x = Math.PI / 2;
      }

      coefsA = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];
      coefsB = [[-1, 1, 1], [1, 1, 1], [1, 1, -1], [-1, 1, -1]];
      for (var i = 0; i < coefsA.length; i++) {
        var spCorner = this._spCorner(i, 1);
        this._setPos(spCorner, coefsA[i], xyz);
        spCorner = this._spCorner(i);
        this._setPos(spCorner, coefsB[i], xyz);
      }

      let geo = new Geometry();
      this.root.traverse(e => {
        if (e.geometry) {
          e.geometry = new Geometry().fromBufferGeometry(e.geometry);
          geo.mergeMesh(e);
        }
      });
      this.copy(geo.toBufferGeometry());
    }

    _plane(xi, yi, xyz)
    {
      var m = new THREE.Mesh(new THREE.PlaneGeometry(2 * xyz[xi], 2 * xyz[yi]));
      this.root.add(m);
      return m;
    }

    _setPos(mesh, coefs, xyz)
    {
      mesh.position.set(coefs[0] * xyz[0], coefs[1] * xyz[1], coefs[2] * xyz[2]);
    }

    _spCorner(i, j)
    {
      var m = new THREE.Mesh(new THREE.SphereGeometry(this.radius, this.spans, this.spans,
              i * Math.PI / 2, Math.PI / 2,
              (j || 0) * Math.PI / 2, Math.PI / 2
      ));
      this.root.add(m);
      return m;

    }

    _cyl(l, i)
    {
      var m = new THREE.Mesh(new THREE.CylinderGeometry(
              this.radius, this.radius, l - 2 * this.radius, this.spans,
              1, true, i * Math.PI / 2, Math.PI / 2));
      this.root.add(m);
      return m;
    }
    ;

  }


  document.fonts.ready.then(function() {
    window.app = new App();
  });
</script>
</html>
